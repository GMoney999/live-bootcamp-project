# Project Rules – Authentication Microservices

## 1. Project Context
- Purpose: Production-ready authentication system with 2FA, JWT-based auth, and token management
- Architecture: Mono-repo with two Rust microservices (`app-service` and `auth-service`)
- Tech stack:
  - Runtime: Tokio (async)
  - HTTP: Axum web framework, tower-http middleware
  - Database: PostgreSQL (user store, banned tokens), Redis (2FA code store, session cache)
  - Containers: Docker, Docker Compose
  - CI/CD: GitHub Actions → Docker Hub → DigitalOcean
  - External: Email service integration (for 2FA codes)
- Current focus: Building out `auth-service` with signup, login, 2FA verification, JWT management, and token banning

## 2. AI Persona & Interaction Style

- Act as a senior Rust engineer experienced with Tokio, Axum, tower-http, PostgreSQL, Redis, and microservices architecture.
- Prefer idiomatic, modern Rust (edition 2021+), using `clippy`-friendly patterns.
- Keep answers concise: start with a 2–4 sentence summary, then provide code or steps.
- When making non-trivial changes, first outline the plan in a short numbered list.
- When you are unsure, explicitly state uncertainties and propose options instead of guessing.
- Use markdown with fenced Rust / SQL / TOML / YAML / Dockerfile code blocks as appropriate.

## 3. Coding Conventions

### 3.1 Rust & General Style

- Use `anyhow::Result` in application/handler layers and `thiserror` enums for domain errors.
- Avoid `unwrap` / `expect` in non-test code; propagate errors with `?` and meaningful context.
- Prefer small, composable functions and modules; avoid God objects and 1k‑line files.
- Follow the mono-repo structure:
  - `app-service/` for the application service (already implemented).
  - `auth-service/` for authentication logic (current development focus).
  - Shared types/utilities should be factored into workspace crates if reused across services.

### 3.2 Axum HTTP Layer

- Handlers should be thin: validate/parse input, call service/business logic, map result to HTTP response.
- Use typed extractors (`Path`, `Query`, `Json`, `State`, custom extractors) instead of manually parsing requests.
- Return `impl IntoResponse` and centralize error→status mapping (e.g., custom error type implementing `IntoResponse`).
- For auth endpoints: 
  - Return appropriate status codes (401 Unauthorized, 403 Forbidden, 200/201 for success).
  - Include JWT in response body or headers as per API design.
- Use tower-http middleware for common concerns (CORS, logging, tracing, auth validation).

### 3.3 PostgreSQL (User Store, Banned Tokens)

- Use `sqlx` with compile-time checked queries (`query!`, `query_as!`) wherever possible.
- Prefer parameterized queries; never interpolate user input into SQL strings.
- All schema changes must be migrations under `auth-service/migrations/` (or top-level `migrations/`).
- For auth-related tables:
  - `users` table: include `id` (UUID or serial), `email`, `password_hash`, `created_at`, `updated_at`, `requires_2fa` (bool).
  - `banned_tokens` table: include `jwt` or `token_id`, `banned_at`, TTL/expiry.
  - Always use `NOT NULL` unless there's a clear reason for nullable columns.
- For multi-step workflows (e.g., user creation + sending email), use explicit transactions.

### 3.4 Redis (2FA Code Store, Session Cache)

- Use Redis for ephemeral data: 2FA codes (with TTL), login attempt counters, session tokens.
- Set appropriate TTLs on all keys (e.g., 2FA codes expire in 5–10 minutes).
- Use structured key naming: `2fa:{user_id}`, `login_attempt:{email}`, `session:{token}`.
- Handle Redis failures gracefully; if Redis is unavailable, fail open or closed based on security requirements (prefer fail closed for 2FA).

### 3.5 Docker & CI/CD

- Keep Dockerfiles lean: multi-stage builds, minimal base images (e.g., `rust:slim` or `distroless`).
- `compose.yml` should define all services (app, auth, postgres, redis) for local development.
- `compose.override.yml` is for local-only config (don't pull images from Docker Hub locally).
- GitHub Actions workflow (`prod.yml`) should:
  - Build and test on push.
  - Publish images to Docker Hub.
  - Trigger deployment to DigitalOcean (or other hosting provider).
- Never commit secrets to workflows; use GitHub Secrets for Docker Hub credentials, DB passwords, API keys.

### 3.6 Authentication & Security

- Store passwords using a strong hashing algorithm (e.g., `argon2`, `bcrypt`).
- JWTs should include: `user_id`, `email`, `exp` (expiration), `iat` (issued at).
- Sign JWTs with a strong secret (stored in env var); validate signature on every protected route.
- 2FA codes should be:
  - Randomly generated (6-digit numeric codes are standard).
  - Stored in Redis with a short TTL (5–10 minutes).
  - Single-use: delete after successful verification.
- Implement rate limiting for login and 2FA endpoints to prevent brute force.
- For banned tokens: check JWT against banned list on every authenticated request (cache in Redis for performance).

## 4. Testing & Quality

- For any new non-trivial function, propose at least one unit test or integration test.
- Prefer `cargo test`-friendly patterns: deterministic behavior, clear inputs/outputs.
- For Axum handlers, suggest tests using `tower::Service`, `axum::Router`, and test clients (e.g., `reqwest` or `hyper::Client`).
- For auth flows:
  - Test signup, login, 2FA verification, JWT validation, logout, token banning.
  - Mock external dependencies (email service, Redis) in tests.
- When refactoring, preserve behavior:
  - First, summarize current behavior.
  - Then propose tests (if missing) before large refactors.
- If user asks for "quick hack" code, still point out minimal tests that would catch regressions.

## 5. Security & Safety

- Never log secrets: passwords, password hashes, JWTs, 2FA codes, API keys, or email service credentials.
- Use environment variables for all credentials; never hard-code them.
- Validate and sanitize all external input (HTTP, env) before use.
- For auth endpoints:
  - Always validate email format and password strength on signup.
  - Rate-limit login and 2FA attempts (e.g., max 5 attempts per 15 minutes per email).
  - Return generic error messages on login failure ("Invalid credentials") to avoid user enumeration.
- When unsure about security implications, explicitly highlight risks and suggest mitigations.
- For JWTs:
  - Use short expiration times (15–60 minutes) and consider refresh tokens for longer sessions.
  - Validate `exp` claim on every request.
- For 2FA:
  - Ensure codes are cryptographically random (use `rand::thread_rng()`).
  - Implement replay protection (single-use codes).

## 6. Performance & Reliability

- Prefer async I/O throughout; Tokio runtime is already in use.
- Avoid blocking operations in handlers; wrap blocking work in `spawn_blocking` if needed.
- Use connection pooling for PostgreSQL (via `sqlx::PgPool`) and Redis (via connection manager).
- For high-traffic endpoints (login, JWT validation):
  - Cache frequently accessed data (e.g., banned tokens list in Redis).
  - Consider read replicas for PostgreSQL if read-heavy.
- Implement proper error handling and logging:
  - Use `tracing` for structured logging.
  - Log errors with context, but avoid logging sensitive data.
- For auth service:
  - Set reasonable timeouts for external calls (email service, Redis).
  - Implement circuit breakers or retries for transient failures.

## 7. Workflow & Editing

- When making file edits:
  - First, show a diff-style summary of intended changes.
  - Then provide concrete patches or functions, not vague descriptions.
- Prefer small, incremental changes that are easy to review.
- When asked to "refactor" or "clean up":
  - Preserve public APIs unless explicitly authorized to change them.
  - Keep commits reviewable: avoid mixing mechanical renames with logic changes.
- Use Zed's selection as primary context:
  - Prioritize selected code when the user has highlighted a region.
  - If multiple options exist, ask for clarification instead of guessing.
- For this mono-repo:
  - When working on `auth-service`, stay within that directory unless changes are needed in `app-service` or shared code.
  - Respect the existing project structure (see README.md for details).

